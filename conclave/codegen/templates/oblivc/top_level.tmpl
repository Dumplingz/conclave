#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <obliv.oh>

#include "protocol.h"

int checkInputCols
	(
	int colsOne,
	int colsTwo
	)
{
	if (colsOne != colsTwo)
	{
		printf("Unequal number of cols.");
		exit(1);
	}
	else
	{
	return colsOne;
	}
}

void matToObliv
	(
	protocolIo *io,
	int party,
	intermediateMat *ret
	)
{
	int numRows = ocBroadcastInt(io->rows, party);
	int numCols = ocBroadcastInt(io->cols, party);

	obliv int **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = feedOblivInt(io->mat[i][j], party);
		}
	}

	ret->rows = numRows;
	ret->cols = numCols;
	ret->mat = array;
}

void addRow
	(
	obliv int *srcOne,
	obliv int *srcTwo,
	obliv int *dest,
	int colsInOne,
	int colsInTwo,
	int joinColTwo
	) obliv
{

	obliv int a = 1;
	dest[0] = a;
	for (int i = 1; i < colsInOne + 1; i++)
	{
		dest[i] = srcOne[i - 1];
	}

	int m = colsInOne + 1;
	for (int i = 0; i < colsInTwo; i++)
	{
		if (i != joinColTwo)
		{
			dest[m] = srcTwo[i];
			m++;
		}
	}
}

void concat
	(
	intermediateMat *matOne,
	intermediateMat *matTwo,
	intermediateMat *ret
	)
{
	int numCols = checkInputCols(matOne->cols, matTwo->cols);
	int numRows = matOne->rows + matTwo->rows;

	obliv int **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < matOne->rows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = matOne->mat[i][j];
		}
	}

	int m = 0;
	for (int i = matOne->rows; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = matTwo->mat[m][j];
		}
		m++;
	}

	ret->rows = numRows;
	ret->cols = numCols;
	ret->mat = array;

}

void join
	(
	intermediateMat *matOne,
	intermediateMat *matTwo,
	intermediateMat *ret,
	int joinColOne,
	int joinColTwo
	)
{

	int numColsOne = matOne->cols;
	int numColsTwo = matTwo->cols;

	int numRowsOne = matOne->rows;
	int numRowsTwo = matTwo->rows;

	int numOutCols = numColsOne + numColsTwo;
	int maxOutRows = numRowsOne * numRowsTwo;

	obliv int **array = malloc(sizeof(*array) * maxOutRows);

	int currentRow = 0;
	obliv int matchRows = 0;

	for (int i = 0; i < numRowsOne; i++)
	{
		for (int j = 0; j < numRowsTwo; j++)
		{
			array[currentRow] = calloc(numOutCols, sizeof(**array));
			obliv if (matOne->mat[i][joinColOne] == matTwo->mat[j][joinColTwo])
			{
				addRow(matOne->mat[i], matTwo->mat[j], array[currentRow], numColsOne, numColsTwo, joinColTwo);
				matchRows++;
			}
			currentRow++;
		}
	}

	int outRows;
	revealOblivInt(&outRows, matchRows, 0);

	obliv int **outArray = malloc(sizeof(*outArray) * outRows);

	int currentRow = 0;
	for (int i = 0; i < maxOutRows; i++)
	{
		int matchReveal;
		revealOblivInt(&matchReveal, array[i][0], 0);
		if (matchReveal == 1)
		{
			outArray[currentRow] = malloc(sizeof(**outArray) * (numOutCols - 1));
			for (int j = 0; j < numOutCols - 1; j++)
			{
				outArray[currentRow][j] = array[i][j + 1];
			}
			currentRow++;
		}
		free(array[i]);
	}

	ret->rows = outRows;
	ret->cols = numOutCols - 1;
	ret->mat = outArray;
}

void project
	(
	intermediateMat *mat,
	intermediateMat *ret,
	int *projCols
	)
{
	int numRows = mat->rows;
	int numCols = ret->cols;

	obliv int **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			int idx = projCols[j];
			array[i][j] = mat->mat[i][idx];
		}
	}

	ret->rows = numRows;
	ret->mat = array;
}

void multiply
	(
	intermediateMat *mat,
	intermediateMat *ret,
	int *operands,
	int numOperands,
	int scalar,
	int opColIdx,
	bool newCol
	)
{
	int numRows = mat->rows;
	int numCols = mat->cols;
	if (newCol)
	{
		numCols++;
	}

	obliv int **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			if (j != opColIdx)
			{
				array[i][j] = mat->mat[i][j];
			}
			else
			{
				obliv int temp = 1;
				temp = temp * scalar;
				for (int k = 0; k < numOperands; k++)
				{
					int colIdx = operands[k];
					temp = temp * mat->mat[i][colIdx];
				}
				array[i][j] = temp;
			}
		}
	}

	ret->cols = numCols;
	ret->rows = numRows;
	ret->mat = array;
}

void revealResult
	(
	intermediateMat *mat,
	int party,
	protocolIo *io
	)
{
	int **array = malloc(sizeof(*array) * mat->rows);

	for (int i = 0; i < mat->rows; i++)
	{
		array[i] = malloc(sizeof(**array) * mat->cols);
		for (int j = 0; j < mat->cols; j++)
		{
			revealOblivInt(&array[i][j], mat->mat[i][j], party);
		}
	}
	io->ret = array;
	io->rows = mat->rows;
	io->cols = mat->cols;
}

void protocol(void *args)
{

	protocolIo *io = (protocolIo*) args;

{{{PROTOCOL CODE}}}

}