#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <obliv.oh>
#include <math.h>

#include "workflow.h"

int checkInputCols
	(
	int colsOne,
	int colsTwo
	)
{
	if (colsOne != colsTwo)
	{
		printf("Unequal number of cols.");
		exit(1);
	}
	else
	{
	    return colsOne;
	}
}

int nextPowerOf2(int n)
{
    int p = 1;
    if (n && !(n & (n - 1)))
        return n;

    while (p < n)
        p <<= 1;

    return p;
}

obliv float** padInput
    (
    obliv float **arr,
    int numCols,
    int numRows,
    int nextVal
    )
{

    obliv float **ret = malloc(sizeof(*ret) * nextVal);

    for (int i = 0; i < numRows; i++)
    {
        ret[i] = malloc(sizeof(**ret) * numCols);
        for (int j = 0; j < numCols; j++)
        {
            ret[i][j] = arr[i][j];
        }
    }

    for (int i = numRows; i < nextVal; i++)
    {
        ret[i] = malloc(sizeof(**ret) * numCols);
        for (int j = 0; j < numCols; j++)
        {
            ret[i][j] = 0;
        }
    }

    return ret;
}

bool isPowerOfTwo(int n)
{
   return (ceil(log2(n)) == floor(log2(n)));
}

void matToObliv
	(
	Io *io,
	int party,
	intermediateMat *ret
	)
{
	int numRows = ocBroadcastInt(io->rows, party);
	int numCols = ocBroadcastInt(io->cols, party);

	obliv float **array = malloc(sizeof(*array) * numRows);
	obliv int *keepRows = malloc(sizeof(obliv int) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		keepRows[i] = 1;
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = feedOblivFloat(io->mat[i][j], party);
		}
	}

	ret->rows = numRows;
	ret->cols = numCols;
	ret->mat = array;
	ret->keepRows = keepRows;
}

void concat
	(
	intermediateMat *matOne,
	intermediateMat *matTwo,
	intermediateMat *ret
	)
{
	int numCols = checkInputCols(matOne->cols, matTwo->cols);
	int numRows = matOne->rows + matTwo->rows;

	obliv int *keepRows = malloc(sizeof(obliv int) * numRows);
	obliv float **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < matOne->rows; i++)
	{
		keepRows[i] = matOne->keepRows[i];

		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = matOne->mat[i][j];
		}
	}

	int m = 0;
	for (int i = matOne->rows; i < numRows; i++)
	{
		keepRows[i] = matTwo->keepRows[m];

		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = matTwo->mat[m][j];
		}
		m++;
	}

	ret->rows = numRows;
	ret->cols = numCols;
	ret->mat = array;
	ret->keepRows = keepRows;
}

void addRow
	(
		obliv float *srcOne,
		obliv float *srcTwo,
		obliv float *dest,
		int colsInOne,
		int colsInTwo,
		int joinColTwo
	)
{
	for (int i = 0; i < colsInOne; i++)
	{
		dest[i] = srcOne[i];
	}

	int m = colsInOne;
	for (int i = 0; i < colsInTwo; i++)
	{
		if (i != joinColTwo)
		{
			dest[m] = srcTwo[i];
			m++;
		}
	}
}

void join
	(
	intermediateMat *matOne,
	intermediateMat *matTwo,
	intermediateMat *ret,
	int joinColOne,
	int joinColTwo
	)
{

	int numColsOne = matOne->cols;
	int numColsTwo = matTwo->cols;

	int numRowsOne = matOne->rows;
	int numRowsTwo = matTwo->rows;

	int numOutCols = numColsOne + numColsTwo - 1;
	int maxOutRows = numRowsOne * numRowsTwo;

	obliv float **array = malloc(sizeof(*array) * maxOutRows);
	obliv int *keepRows = malloc(sizeof(obliv int) * maxOutRows);

	int currentRow = 0;

	for (int i = 0; i < numRowsOne; i++)
	{
		for (int j = 0; j < numRowsTwo; j++)
		{
			array[currentRow] = malloc(sizeof(**array) * numOutCols);
			addRow(matOne->mat[i], matTwo->mat[j], array[currentRow], numColsOne, numColsTwo, joinColTwo);

			// check keepRow flags for both rows
			obliv int keepThisRow = matOne->keepRows[i] * matTwo->keepRows[j];

			obliv if (matOne->mat[i][joinColOne] == matTwo->mat[j][joinColTwo])
			{
				keepRows[currentRow] = keepThisRow;
			}
			else
			{
				keepRows[currentRow] = 0;
			}
			currentRow++;
		}
	}

	ret->rows = maxOutRows;
	ret->cols = numOutCols;
	ret->mat = array;
	ret->keepRows = keepRows;
}

void addRowLeaky
	(
	obliv float *srcOne,
	obliv float *srcTwo,
	obliv float *dest,
	int colsInOne,
	int colsInTwo,
	int joinColTwo
	) obliv
{

	obliv float a = 1;
	dest[0] = a;
	for (int i = 1; i < colsInOne + 1; i++)
	{
		dest[i] = srcOne[i - 1];
	}

	int m = colsInOne + 1;
	for (int i = 0; i < colsInTwo; i++)
	{
		if (i != joinColTwo)
		{
			dest[m] = srcTwo[i];
			m++;
		}
	}
}

void joinLeaky
	(
	intermediateMat *matOne,
	intermediateMat *matTwo,
	intermediateMat *ret,
	int joinColOne,
	int joinColTwo
	)
{

	int numColsOne = matOne->cols;
	int numColsTwo = matTwo->cols;

	int numRowsOne = matOne->rows;
	int numRowsTwo = matTwo->rows;

	int numOutCols = numColsOne + numColsTwo;
	int maxOutRows = numRowsOne * numRowsTwo;

	obliv float **array = malloc(sizeof(*array) * maxOutRows);

	int currentRow = 0;
	obliv int matchRows = 0;

	for (int i = 0; i < numRowsOne; i++)
	{
		for (int j = 0; j < numRowsTwo; j++)
		{
			array[currentRow] = calloc(numOutCols, sizeof(**array));
			obliv if (matOne->mat[i][joinColOne] == matTwo->mat[j][joinColTwo])
			{
				addRowLeaky(matOne->mat[i], matTwo->mat[j], array[currentRow], numColsOne, numColsTwo, joinColTwo);
				matchRows++;
			}
			currentRow++;
		}
	}

	int outRows;
	revealOblivInt(&outRows, matchRows, 0);

	obliv float **outArray = malloc(sizeof(*outArray) * outRows);

	int currentRow = 0;
	for (int i = 0; i < maxOutRows; i++)
	{
		float matchReveal;
		revealOblivFloat(&matchReveal, array[i][0], 0);
		if (matchReveal == 1)
		{
			outArray[currentRow] = malloc(sizeof(**outArray) * (numOutCols - 1));
			for (int j = 0; j < numOutCols - 1; j++)
			{
				outArray[currentRow][j] = array[i][j + 1];
			}
			currentRow++;
		}
		free(array[i]);
	}

	ret->rows = outRows;
	ret->cols = numOutCols - 1;
	ret->mat = outArray;
}

void project
	(
	intermediateMat *mat,
	intermediateMat *ret,
	int *projCols
	)
{
	int numRows = mat->rows;
	int numCols = ret->cols;

	obliv float **array = malloc(sizeof(*array) * numRows);
	obliv int *keepRows = malloc(sizeof(obliv int) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		keepRows[i] = mat->keepRows[i];

		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			int idx = projCols[j];
			array[i][j] = mat->mat[i][idx];
		}
	}

	ret->rows = numRows;
	ret->mat = array;
	ret->keepRows = keepRows;
}

void multiply
	(
	intermediateMat *mat,
	intermediateMat *ret,
	int *operands,
	int numOperands,
	float scalar,
	int opColIdx,
	bool newCol
	)
{
	int numRows = mat->rows;
	int numCols = mat->cols;

	if (newCol)
	{
		numCols++;
	}

	obliv float **array = malloc(sizeof(*array) * numRows);
	obliv int *keepRows = malloc(sizeof(obliv int) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		keepRows[i] = mat->keepRows[i];
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			if (j != opColIdx)
			{
				array[i][j] = mat->mat[i][j];
			}
			else
			{
				obliv float temp = 1;
				temp = temp * scalar;
				for (int k = 0; k < numOperands; k++)
				{
					int colIdx = operands[k];
					temp = temp * mat->mat[i][colIdx];
				}
				array[i][j] = temp;
			}
		}
	}

	ret->cols = numCols;
	ret->rows = numRows;
	ret->mat = array;
	ret->keepRows = keepRows;
}

void divide
	(
	intermediateMat *mat,
	intermediateMat *ret,
	int *operands,
	int numOperands,
	float scalar,
	int opColIdx,
	bool newCol
	)
{
	int numRows = mat->rows;
	int numCols = mat->cols;

	if (newCol)
	{
		numCols++;
	}

	obliv float **array = malloc(sizeof(*array) * numRows);
	obliv int *keepRows = malloc(sizeof(obliv int) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		keepRows[i] = mat->keepRows[i];
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			if (j != opColIdx)
			{
				array[i][j] = mat->mat[i][j];
			}
			else
			{
				int initCol = operands[0];
				obliv float temp = mat->mat[i][initCol] / scalar;
				for (int k = 1; k < numOperands; k++)
				{
					int colIdx = operands[k];
					temp = temp / mat->mat[i][colIdx];
				}
				array[i][j] = temp;
			}
		}
	}

	ret->cols = numCols;
	ret->rows = numRows;
	ret->mat = array;
	ret->keepRows = keepRows;
}

void compareExchange
	(
		obliv float **array,
		obliv int *keepRows,
		int keyCol,
		int numCols,
		int i,
		int j,
		bool ascending
	)
{
	obliv float x = array[i][keyCol];
	obliv float y = array[j][keyCol];

	obliv float c;
	obliv float d;

	obliv int cc;
	obliv int dd;

	if (ascending)
	{
		obliv if (x < y)
		{
			c = 1;
			cc = 1;
			d = 0;
			dd = 0;
		}
		else
		{
			c = 0;
			cc = 0;
			d = 1;
			dd = 1;
		}
	}
	else
	{
		obliv if (x > y)
		{
			c = 1;
			cc = 1;
			d = 0;
			dd = 0;
		}
		else
		{
			c = 0;
			cc = 0;
			d = 1;
			dd = 1;
		}
	}

	obliv int keepRowsI = (cc * keepRows[i]) + (dd * keepRows[j]);
	obliv int keepRowsJ = (dd * keepRows[i]) + (cc * keepRows[j]);

	obliv float *temp1 = malloc(sizeof(obliv float) * numCols);
	obliv float *temp2 = malloc(sizeof(obliv float) * numCols);

	for (int k = 0; k < numCols; k++)
	{
		obliv float a = array[i][k];
		obliv float b = array[j][k];

		temp1[k] = (c * a) + (d * b);
		temp2[k] = (d * a) + (c * b);
	}

	array[i] = temp1;
	array[j] = temp2;

	keepRows[i] = keepRowsI;
	keepRows[j] = keepRowsJ;
}

void oddEvenMerge
	(
		obliv float **array,
		obliv int *keepRows,
		int keyCol,
		int numCols,
		int lo,
		int n,
		int r,
		bool ascending
	)
{
	int m = r * 2;
	if (m < n)
	{
		oddEvenMerge(array, keepRows, keyCol, numCols, lo, n, m, ascending);
		oddEvenMerge(array, keepRows, keyCol, numCols, lo + r, n, m, ascending);

		for (int i = lo + r; (i + r) < (lo + n); i += m)
		{
			compareExchange(array, keepRows, keyCol, numCols, i, i + r, ascending);
		}
	} else {
		compareExchange(array, keepRows, keyCol, numCols, lo, lo + r, ascending);
	}
}

void oddEvenSort
	(
		obliv float **array,
		obliv int *keepRows,
		int keyCol,
		int numCols,
		int lo,
		int n,
		bool ascending
	)
{
	if (n > 1)
	{
		int m = n / 2;
		oddEvenSort(array, keepRows, keyCol, numCols, lo, m, ascending);
		oddEvenSort(array, keepRows, keyCol, numCols, lo + m, m, ascending);
		oddEvenMerge(array, keepRows, keyCol, numCols, lo, n, 1, ascending);
	}
}

void sortBy
	(
		intermediateMat *mat,
		intermediateMat *ret,
		int keyCol
	)
{
	int numRows = mat->rows;
	int numCols = mat->cols;

	obliv float **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		for (int j = 0; j < numCols; j++)
		{
			array[i][j] = mat->mat[i][j];
		}
	}

	if (!isPowerOfTwo(numRows))
	{
		int paddedVal = nextPowerOf2(numRows);
		obliv float **padded = padInput(array, numCols, numRows, paddedVal);
		obliv int *keepRows = malloc(sizeof(obliv int) * paddedVal);

		for (int i = 0; i < paddedVal; i++)
		{
			if (i < numRows)
			{
				keepRows[i] = mat->keepRows[i];
			}
			else
			{
				keepRows[i] = 0;
			}
		}

		oddEvenSort(padded, keepRows, keyCol, numCols, 0, numRows, true);

		ret->mat = padded;
		ret->keepRows = keepRows;
	}
	else
	{
		obliv int *keepRows = malloc(sizeof(obliv int) * numRows);

		for (int i = 0; i < numRows; i++)
		{
			keepRows[i] = mat->keepRows[i];
		}

		oddEvenSort(array, keepRows, keyCol, numCols, 0, numRows, true);

		ret->mat = array;
		ret->keepRows = keepRows;
	}

	ret->rows = numRows;
	ret->cols = numCols;
}

void shiftAgg
	(
		obliv float **arr,
		obliv int *keepRows,
		int numRows
	)
{

	for (int i = 0; i < numRows - 1; i++)
	{
		obliv float eqFlagFlt;
		obliv int eqFlagInt;

		obliv if (arr[i][0] == arr[i + 1][0])
		{
			eqFlagFlt = 1;
			eqFlagInt = 1;
		}
		else
		{
			eqFlagFlt = 0;
			eqFlagInt = 0;
		}

		// only touch data if both rows are keepRows
		obliv if (keepRows[i] * keepRows[i + 1] * eqFlagInt)
		{
			obliv float temp1 = arr[i][1] * (1 - eqFlagFlt);
			obliv float temp2 = arr[i + 1][1] + (arr[i][1] * eqFlagFlt);
			arr[i][1] = temp1;
			arr[i + 1][1] = temp2;

			keepRows[i] = 0;
		}
	}
}

void _agg
	(
		intermediateMat *ret,
		obliv float **array,
		int keyCol,
		int aggCol,
		int numCols,
		int numRows
	)
{

		oddEvenSort(array, ret->keepRows, 0, numCols, 0, numRows, true);
		shiftAgg(array, ret->keepRows, numRows);

		// TODO: move shuffle into it's own function.
		oddEvenSort(array, ret->keepRows, 1, numCols, 0, numRows, false);

		obliv float **retArray = malloc(sizeof(*retArray) * numRows);

		for (int i = 0; i < numRows; i++)
		{
			retArray[i] = malloc(sizeof(**retArray) * numCols);
			retArray[i][0] = array[i][0];
			retArray[i][1] = array[i][1];
		}

		ret->mat = retArray;
		ret->rows = numRows;
		ret->cols = numCols;
}

void _aggLeaky
	(
		intermediateMat *ret,
		obliv float **array,
		int keyCol,
		int aggCol,
		int numCols,
		int numRows
	)
{

		oddEvenSort(array, ret->keepRows, 0, numCols, 0, numRows, true);
		shiftAgg(array, ret->keepRows, numRows);

		// TODO: move shuffle into it's own function.
		oddEvenSort(array, ret->keepRows, 1, numCols, 0, numRows, false);

		obliv int outRows = 0;

		for (int i = 0; i < numRows; i++)
		{
			obliv if (ret->keepRows[i] != 0)
			{
				outRows++;
			}
		}

		int numOutRows;
		revealOblivInt(&numOutRows, outRows, 0);

		obliv float **retArray = malloc(sizeof(*retArray) * numOutRows);

		for (int i = 0; i < numOutRows; i++)
		{
			retArray[i] = malloc(sizeof(**retArray) * numCols);
			retArray[i][0] = array[i][0];
			retArray[i][1] = array[i][1];
		}

		ret->mat = retArray;
		ret->rows = numOutRows;
		ret->cols = numCols;
}

void agg
	(
		intermediateMat *mat,
		intermediateMat *ret,
		int keyCol,
		int aggCol,
		bool leaky
	)
{
	// TODO: numCols hardcoded as 2, generalize for multiple aggCols
	int numRows = mat->rows;
	int numCols = 2;

	obliv float **array = malloc(sizeof(*array) * numRows);

	for (int i = 0; i < numRows; i++)
	{
		array[i] = malloc(sizeof(**array) * numCols);
		array[i][0] = mat->mat[i][keyCol];
		array[i][1] = mat->mat[i][aggCol];
	}

	if (!isPowerOfTwo(numRows))
	{
		int paddedVal = nextPowerOf2(numRows);
		obliv float **padded = padInput(array, numCols, numRows, paddedVal);

		obliv int *keepRows = malloc(sizeof(obliv int) * paddedVal);
		for (int i = 0; i < paddedVal; i++)
		{
			if (i < numRows)
			{
				keepRows[i] = mat->keepRows[i];
			}
			else
			{
				keepRows[i] = 0;
			}
		}

		ret->keepRows = keepRows;

        if (leaky)
        {
            _aggLeaky(ret, padded, keyCol, aggCol, numCols, paddedVal);
        }
        else
        {
		    _agg(ret, padded, keyCol, aggCol, numCols, paddedVal);
		}
	}
	else
	{
		obliv int *keepRows = malloc(sizeof(obliv int) * numRows);

		for (int i = 0; i < numRows; i++)
		{
			keepRows[i] = mat->keepRows[i];
		}

		ret->keepRows = keepRows;
        if (leaky)
        {
            _aggLeaky(ret, array, keyCol, aggCol, numCols, numRows);
        }
        else
        {
		    _agg(ret, array, keyCol, aggCol, numCols, numRows);
		}
	}
}

void revealResult
	(
	intermediateMat *mat,
	int party,
	protocolIo *io
	)
{

	int *keepFlags = malloc(sizeof(int) * mat->rows);
	int outRows = 0;

	for (int i = 0; i < mat->rows; i++)
	{
		revealOblivInt(&keepFlags[i], mat->keepRows[i], 0);
		if (keepFlags[i] == 1)
		{
			outRows++;
		}
	}

	float **array = malloc(sizeof(*array) * outRows);

	int currentRetIdx = 0;
	for (int i = 0; i < mat->rows; i++)
	{
		if (keepFlags[i] == 1)
		{
			array[currentRetIdx] = malloc(sizeof(**array) * mat->cols);
			for (int j = 0; j < mat->cols; j++)
			{
				revealOblivFloat(&array[currentRetIdx][j], mat->mat[i][j], party);
			}
			currentRetIdx++;
		}
	}

	io->ret = array;
	io->out_rows = outRows;
	io->out_cols = mat->cols;
}

void protocol(void *args)
{

    protocolIo *io = (protocolIo*) args;
{{{OP_CODE}}}

}